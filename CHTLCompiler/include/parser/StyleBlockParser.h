#pragma once

#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include "ast/ASTNode.h"
#include "lexer/CHTLLexer.h"
#include "parser/AttributeSystem.h"

namespace chtl {

// 样式块配置
struct StyleBlockConfig {
    bool enable_inline_styles;           // 启用内联样式
    bool enable_auto_selectors;          // 启用自动化选择器
    bool enable_context_reference;       // 启用上下文引用(&)
    bool strict_css_validation;         // 严格CSS验证
    bool auto_generate_classes;          // 自动生成类名
    bool auto_generate_ids;              // 自动生成ID
    size_t max_css_property_length;     // 最大CSS属性长度
    size_t max_css_value_length;        // 最大CSS值长度
    
    StyleBlockConfig() : 
        enable_inline_styles(true), enable_auto_selectors(true), 
        enable_context_reference(true), strict_css_validation(false),
        auto_generate_classes(true), auto_generate_ids(true),
        max_css_property_length(100), max_css_value_length(500) {}
};

// 样式规则信息
struct StyleRuleInfo {
    std::string selector;                // 选择器
    std::string property;                // CSS属性
    std::string value;                   // CSS值
    std::string original_value;          // 原始值
    size_t line;                         // 行号
    size_t column;                       // 列号
    bool is_inline;                      // 是否为内联样式
    bool is_auto_generated;              // 是否为自动生成
    std::unordered_map<std::string, std::string> metadata; // 元数据
    
    StyleRuleInfo() : line(0), column(0), is_inline(false), is_auto_generated(false) {}
};

// 局部样式块解析器类
class StyleBlockParser {
public:
    StyleBlockParser(const StyleBlockConfig& config = StyleBlockConfig());
    ~StyleBlockParser();
    
    // 样式块解析
    std::shared_ptr<ASTNode> parseStyleBlock(const std::vector<Token>& tokens, size_t& position);
    std::vector<StyleRuleInfo> parseStyleRules(const std::vector<Token>& tokens, size_t& position);
    
    // 内联样式解析
    std::vector<StyleRuleInfo> parseInlineStyles(const std::vector<Token>& tokens, size_t& position);
    
    // 选择器解析
    std::string parseSelector(const std::vector<Token>& tokens, size_t& position);
    bool isClassSelector(const std::string& selector);
    bool isIdSelector(const std::string& selector);
    bool isPseudoSelector(const std::string& selector);
    
    // 上下文引用解析
    std::string resolveContextReference(const std::string& reference, const std::string& element_name);
    std::string expandContextReference(const std::string& reference, const std::string& base_selector);
    
    // CSS规则解析
    std::pair<std::string, std::string> parseCSSRule(const std::vector<Token>& tokens, size_t& position);
    bool validateCSSProperty(const std::string& property);
    bool validateCSSValue(const std::string& value);
    
    // 自动化选择器处理
    std::string generateClassName(const std::string& element_name, const std::string& context = "");
    std::string generateIdName(const std::string& element_name, const std::string& context = "");
    void addAutoGeneratedSelector(const std::string& selector, const std::string& element_name);
    
    // 样式块管理
    void addStyleBlock(std::shared_ptr<ASTNode> style_block);
    std::vector<std::shared_ptr<ASTNode>> getStyleBlocks() const;
    std::vector<StyleRuleInfo> getAllStyleRules() const;
    
    // 配置管理
    void setConfig(const StyleBlockConfig& config);
    StyleBlockConfig getConfig() const;
    
    // 错误处理
    bool hasErrors() const;
    std::vector<std::string> getErrors() const;
    void clearErrors();
    void addError(const std::string& error_message);
    
    // 调试和诊断
    std::string getDebugInfo() const;
    void enableDebugMode(bool enable);

private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
    
    // 内部方法
    bool isStyleBlockStart(const std::vector<Token>& tokens, size_t position);
    bool isCSSRuleStart(const std::vector<Token>& tokens, size_t position);
    bool isSelectorStart(const std::vector<Token>& tokens, size_t position);
    void skipWhitespace(const std::vector<Token>& tokens, size_t& position);
    bool isEndOfTokens(const std::vector<Token>& tokens, size_t position);
    
    // CSS验证辅助方法
    bool isValidCSSPropertyName(const std::string& property);
    bool isValidCSSValue(const std::string& value);
    bool isValidSelector(const std::string& selector);
    std::string normalizeCSSValue(const std::string& value);
    
    // 选择器生成辅助方法
    std::string sanitizeElementName(const std::string& element_name);
    std::string generateUniqueSelector(const std::string& base, const std::string& type);
    bool isSelectorAlreadyUsed(const std::string& selector);
};

} // namespace chtl