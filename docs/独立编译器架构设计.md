# CHTL独立编译器架构设计

## 设计原则

根据架构要求，CHTL编译器系统包含4个**完全独立**的编译器，每个编译器只处理特定类型的代码，拥有自己独立的Token系统，**不会混合其他编译器的内容**。

## 4个独立编译器

### 1. CHTL编译器（手写）
**职责**: 处理纯CHTL语法结构
**Token系统**: `PureCHTLToken` / `PureCHTLTokenType`
**处理类型**:
- `CHTL_CORE` - CHTL核心语法
- `CHTL_TEMPLATE` - [Template] 块
- `CHTL_CUSTOM` - [Custom] 块
- `CHTL_CONFIGURATION` - [Configuration] 块
- `CHTL_NAMESPACE` - [Namespace] 块
- `CHTL_IMPORT` - [Import] 块
- `CHTL_TEXT` - text { } 块

**独立性**:
- ✅ 只识别CHTL关键字: `text`, `style`, `script`, `inherit`, `delete`, `insert`, `[Template]`, `[Custom]` 等
- ✅ 只识别CHTL前缀: `@Style`, `@Element`, `@Var`, `@Html`, `@JavaScript`, `@Chtl`, `@CJmod`
- ❌ **不识别** CHTL JS特有语法: `listen`, `delegate`, `animate`, `{{}}`, `->`
- ❌ **不处理** CSS或JavaScript内容

### 2. CHTL JS编译器（手写）
**职责**: 处理CHTL JS扩展语法
**Token系统**: `PureCHTLJSToken` / `PureCHTLJSTokenType`
**处理类型**:
- `CHTL_JS_SCRIPT` - script块中的CHTL JS代码

**独立性**:
- ✅ 只识别CHTL JS特有语法:
  - 增强选择器: `{{this}}`, `{{.button}}`, `{{button[0]}}`
  - 箭头操作符: `->` (与`.`完全等价)
  - CHTL JS关键字: `listen`, `delegate`, `animate`
  - 动画关键字: `duration`, `easing`, `begin`, `end`, `when`, `at`, `loop`, `direction`, `delay`, `callback`
- ✅ 识别必要的JavaScript关键字: `function`, `var`, `let`, `const`, `if`, `else` 等
- ❌ **不识别** 纯CHTL结构语法: `[Template]`, `[Custom]`, `inherit` 等
- ❌ **不处理** CSS内容

### 3. CSS编译器（ANTLR）
**职责**: 处理所有CSS相关内容
**Token系统**: ANTLR CSS语法规则
**处理类型**:
- `CSS_GLOBAL` - 全局CSS文件
- `CSS_LOCAL_STYLE` - style块中的纯CSS代码
- `CSS_ORIGIN` - [Origin] @Style块

**独立性**:
- ✅ 只处理标准CSS语法
- ❌ **不包含** CHTL或CHTL JS内容

### 4. JavaScript编译器（ANTLR）
**职责**: 处理标准JavaScript代码
**Token系统**: ANTLR JavaScript语法规则
**处理类型**:
- `JAVASCRIPT_STANDARD` - 标准JavaScript代码
- `JAVASCRIPT_ORIGIN` - [Origin] @JavaScript块

**独立性**:
- ✅ 只处理标准JavaScript语法
- ❌ **不包含** CHTL JS扩展语法

## 代码片段分类流程

```
1. CHTLUnifiedScanner 扫描源码
2. 识别代码片段类型
3. CompilerDispatcher 根据类型分发到对应编译器

[Template] @Element Box { ... }  → CHTL编译器
script { {{this}}->listen(...) } → CHTL JS编译器  
style { color: red; }            → CSS编译器
[Origin] @JavaScript { ... }     → JavaScript编译器
```

## 架构优势

1. **完全解耦**: 4个编译器互不依赖，可以独立开发和测试
2. **清晰职责**: 每个编译器只关注特定语法，避免复杂性
3. **易于维护**: 修改一个编译器不会影响其他编译器
4. **性能优化**: 每个编译器针对特定语法优化
5. **扩展性强**: 新增语法特性只需修改对应编译器

## 文件结构

```
include/lexer/
├── pure_chtl_tokens.hpp          # CHTL编译器专用Token
├── pure_chtl_js_tokens.hpp       # CHTL JS编译器专用Token
├── global_map.hpp                # 全局符号映射（共享）
├── lexer_state.hpp               # 词法状态管理（共享）
└── lexer_context.hpp             # 解析上下文（共享）

src/compilers/
├── chtl_compiler.cpp             # CHTL编译器实现
├── chtl_js_compiler.cpp          # CHTL JS编译器实现  
├── css_compiler.cpp              # CSS编译器实现（ANTLR）
└── javascript_compiler.cpp       # JavaScript编译器实现（ANTLR）
```

## 验证独立性

运行 `independent_compiler_architecture_test` 可以验证:
- ✅ CHTL编译器不识别CHTL JS语法
- ✅ CHTL JS编译器不识别纯CHTL结构语法  
- ✅ Token系统完全独立
- ✅ 代码片段类型正确分类
- ✅ 增强选择器只属于CHTL JS编译器

## 总结

这种独立编译器架构确保了每个编译器的专业性和独立性，符合"4个编译器相互独立，只包含自己的Token"的要求。每个编译器专注于自己的语法领域，避免了混合Token类型带来的复杂性和潜在错误。