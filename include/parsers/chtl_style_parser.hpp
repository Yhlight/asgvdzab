#pragma once

#include "ast/chtl_ast.hpp"
#include "lexer/chtl_lexer.hpp"
#include "common/types.hpp"
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <unordered_set>

namespace chtl {

/**
 * 局部样式块类型枚举
 */
enum class LocalStyleType {
    INLINE_STYLE,           // 内联样式 (直接CSS属性)
    CLASS_SELECTOR,         // 类选择器 (.className)
    ID_SELECTOR,           // ID选择器 (#idName)
    PSEUDO_CLASS,          // 伪类选择器 (&:hover)
    PSEUDO_ELEMENT,        // 伪元素选择器 (&::before)
    CONTEXT_REFERENCE      // 上下文引用 (&)
};

/**
 * 样式解析状态枚举
 */
enum class StyleParseState {
    INITIAL,               // 初始状态
    READING_SELECTOR,      // 读取选择器
    READING_PROPERTIES,    // 读取属性
    READING_VALUE,         // 读取值
    EXPECTING_SEMICOLON,   // 期望分号
    NESTED_BLOCK          // 嵌套块
};

/**
 * 样式上下文信息
 */
struct StyleContext {
    std::string elementTag;                    // 元素标签名
    std::string elementId;                     // 元素ID (如果有)
    std::string elementClass;                  // 元素类名 (如果有)
    std::unordered_set<std::string> autoGeneratedClasses;  // 自动生成的类名
    std::unordered_set<std::string> autoGeneratedIds;      // 自动生成的ID
    int depth;                                 // 嵌套深度
    
    StyleContext() : depth(0) {}
};

/**
 * CSS属性节点
 */
struct CSSProperty {
    std::string name;
    std::string value;
    Position position;
    
    CSSProperty(const std::string& n, const std::string& v, const Position& pos = Position{})
        : name(n), value(v), position(pos) {}
};

/**
 * 全局样式条目
 */
struct GlobalStyleEntry {
    std::string selector;                      // 选择器
    std::vector<CSSProperty> properties;       // CSS属性列表
    Position position;                         // 位置信息
    
    GlobalStyleEntry(const std::string& sel, const Position& pos = Position{})
        : selector(sel), position(pos) {}
};

/**
 * 局部样式块扫描器
 * 负责扫描和识别样式块中的不同组件
 */
class LocalStyleScanner {
public:
    LocalStyleScanner();
    ~LocalStyleScanner();

    /**
     * 扫描样式内容
     * @param content 样式内容
     * @param context 样式上下文
     * @return 扫描结果
     */
    std::vector<Token> scanStyleContent(const std::string& content, const StyleContext& context);

private:
    std::string content_;
    size_t currentPos_;
    int line_;
    int column_;
    StyleContext context_;

    // 扫描方法
    char currentChar() const;
    char peekChar(size_t offset = 1) const;
    void advance();
    bool isEOF() const;
    Position getCurrentPosition() const;
    
    // 特定扫描方法
    Token scanSelector();
    Token scanProperty();
    Token scanValue();
    Token scanContextReference();
    
    // 工具方法
    bool isAlpha(char c) const;
    bool isDigit(char c) const;
    bool isAlphaNumeric(char c) const;
    bool isWhitespace(char c) const;
    void skipWhitespace();
};

/**
 * 局部样式块状态机
 */
class LocalStyleStateMachine {
public:
    LocalStyleStateMachine();
    ~LocalStyleStateMachine();

    /**
     * 重置状态机
     */
    void reset();

    /**
     * 处理token
     * @param token 输入token
     * @param context 样式上下文
     * @return 是否成功处理
     */
    bool processToken(const Token& token, StyleContext& context);

    /**
     * 获取当前状态
     */
    StyleParseState getCurrentState() const;

    /**
     * 获取收集的内联样式属性
     */
    const std::vector<CSSProperty>& getInlineProperties() const;

    /**
     * 获取收集的全局样式条目
     */
    const std::vector<GlobalStyleEntry>& getGlobalEntries() const;

private:
    StyleParseState currentState_;
    std::vector<CSSProperty> inlineProperties_;
    std::vector<GlobalStyleEntry> globalEntries_;
    
    // 临时状态
    std::string currentSelector_;
    std::string currentProperty_;
    std::string currentValue_;
    Position currentPosition_;

    // 状态转换方法
    void handleInitialState(const Token& token, StyleContext& context);
    void handleReadingSelectorState(const Token& token, StyleContext& context);
    void handleReadingPropertiesState(const Token& token, StyleContext& context);
    void handleReadingValueState(const Token& token, StyleContext& context);
    void handleExpectingSemicolonState(const Token& token, StyleContext& context);
    void handleNestedBlockState(const Token& token, StyleContext& context);

    // 工具方法
    void addInlineProperty(const std::string& name, const std::string& value, const Position& pos);
    void addGlobalEntry(const std::string& selector, const std::vector<CSSProperty>& properties, const Position& pos);
    std::string resolveContextReference(const std::string& selector, const StyleContext& context);
    void generateAutoClass(const std::string& className, StyleContext& context);
    void generateAutoId(const std::string& idName, StyleContext& context);
};

/**
 * CHTL局部样式块解析器
 * 严格按照CHTL语法文档实现局部样式块解析
 */
class CHTLStyleParser {
public:
    CHTLStyleParser();
    ~CHTLStyleParser();

    /**
     * 解析局部样式块
     * @param styleContent 样式内容
     * @param elementContext 元素上下文
     * @return 样式块节点
     */
    CHTLASTNodePtr parseLocalStyleBlock(const std::string& styleContent, const std::string& elementTag);

    /**
     * 设置严格模式
     * @param strict 是否启用严格模式
     */
    void setStrictMode(bool strict);

    /**
     * 获取解析错误
     */
    const std::vector<ParseError>& getErrors() const;

    /**
     * 获取解析警告
     */
    const std::vector<ParseWarning>& getWarnings() const;

    /**
     * 获取生成的全局样式条目
     */
    const std::vector<GlobalStyleEntry>& getGlobalStyleEntries() const;

    /**
     * 清空全局样式条目
     */
    void clearGlobalStyleEntries();

private:
    LocalStyleScanner scanner_;
    LocalStyleStateMachine stateMachine_;
    StyleContext currentContext_;
    
    bool strictMode_;
    std::vector<ParseError> errors_;
    std::vector<ParseWarning> warnings_;
    std::vector<GlobalStyleEntry> globalStyleEntries_;

    // 核心解析方法
    void parseStyleBlock(const std::vector<Token>& tokens);
    void processInlineStyle(const CSSProperty& property, CHTLASTNodePtr styleBlock);
    void processGlobalStyle(const GlobalStyleEntry& entry);

    // 工具方法
    void reportError(const std::string& message, const Position& position = Position{});
    void reportWarning(const std::string& message, const Position& position = Position{});
    std::string generateUniqueClassName();
    std::string generateUniqueIdName();
    bool isValidCSSProperty(const std::string& property) const;
    bool isValidCSSValue(const std::string& value) const;
};

} // namespace chtl