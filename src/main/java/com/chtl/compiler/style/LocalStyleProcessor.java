package com.chtl.compiler.style;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.chtl.ast.CHTLASTNode;
import com.chtl.ast.node.CustomUsageNode;
import com.chtl.ast.node.NumberLiteralNode;
import com.chtl.ast.node.StringLiteralNode;
import com.chtl.ast.node.StyleBlockNode;
import com.chtl.ast.node.StylePropertyNode;
import com.chtl.ast.node.StyleRuleNode;
import com.chtl.ast.node.StyleSelectorNode;
import com.chtl.ast.node.TemplateUsageNode;
import com.chtl.ast.node.UnquotedLiteralNode;
import com.chtl.model.ElementNode;
import com.chtl.ast.*;
import com.chtl.context.CompilationContext;

/**
 * 局部样式处理器
 * 负责处理元素内部的style{}块
 * 严格遵循CHTL语法文档
 */
public class LocalStyleProcessor {
    private final StyleSystem styleSystem;
    private final Map<String, String> autoGeneratedClasses;
    private final Map<String, String> autoGeneratedIds;
    
    public LocalStyleProcessor(StyleSystem styleSystem) {
        this.styleSystem = styleSystem;
        this.autoGeneratedClasses = new HashMap<>();
        this.autoGeneratedIds = new HashMap<>();
    }
    
    /**
     * 处理局部样式块
     * 根据CHTL语法文档：
     * 1. 内联样式 - 直接添加到元素的style属性
     * 2. 类选择器 - 自动添加类名并生成全局样式
     * 3. ID选择器 - 自动添加ID并生成全局样式
     * 4. 伪类/伪元素 - 使用&符号简化，生成全局样式
     */
    public ProcessResult processLocalStyleBlock(StyleBlockNode styleBlock, ElementNode element) {
        ProcessResult result = new ProcessResult();
        
        // 遍历样式块中的所有子节点
        for (CHTLASTNode child : styleBlock.getChildren()) {
            if (child instanceof StylePropertyNode) {
                // 内联样式属性
                StylePropertyNode property = (StylePropertyNode) child;
                String propName = property.getProperty();
                String propValue = getStringValue(property.getValue());
                result.inlineStyles.put(propName, propValue);
                
            } else if (child instanceof StyleRuleNode) {
                // 样式规则（类、ID、伪类等）
                StyleRuleNode rule = (StyleRuleNode) child;
                processStyleRule(rule, element, result);
                
            } else if (child instanceof CustomUsageNode || child instanceof TemplateUsageNode) {
                // 样式组使用 - 交给StyleSystem处理
                result.needsSystemProcessing = true;
            }
        }
        
        return result;
    }
    
    /**
     * 处理样式规则
     */
    private void processStyleRule(StyleRuleNode rule, ElementNode element, ProcessResult result) {
        StyleSelectorNode selectorNode = rule.getSelector();
        String selector = selectorNode != null ? selectorNode.getValue() : "";
        
        if (selector.startsWith(".")) {
            // 类选择器 - 自动添加类名
            String className = selector.substring(1);
            result.classNames.add(className);
            
            // 生成唯一的类名（如果需要）
            String uniqueClassName = generateUniqueClassName(element, className);
            result.globalRules.add(new GlobalRule("." + uniqueClassName, rule));
            
        } else if (selector.startsWith("#")) {
            // ID选择器 - 自动添加ID
            String id = selector.substring(1);
            result.id = id;
            
            // 生成唯一的ID（如果需要）
            String uniqueId = generateUniqueId(element, id);
            result.globalRules.add(new GlobalRule("#" + uniqueId, rule));
            
        } else if (selector.contains("&")) {
            // 上下文推导符号
            // & 会被解析为元素的类名或ID
            result.contextRules.add(new ContextRule(selector, rule));
            
        } else {
            // 其他选择器（伪类、伪元素等）
            result.globalRules.add(new GlobalRule(selector, rule));
        }
    }
    
    /**
     * 生成唯一的类名
     */
    private String generateUniqueClassName(ElementNode element, String baseName) {
        String key = element.getTagName() + "_" + baseName;
        return autoGeneratedClasses.computeIfAbsent(key, k -> {
            // 使用元素标签名和基础类名组合
            return baseName + "_" + element.hashCode();
        });
    }
    
    /**
     * 生成唯一的ID
     */
    private String generateUniqueId(ElementNode element, String baseName) {
        String key = element.getTagName() + "_" + baseName;
        return autoGeneratedIds.computeIfAbsent(key, k -> {
            // 使用元素标签名和基础ID组合
            return baseName + "_" + element.hashCode();
        });
    }
    
    /**
     * 处理结果
     */
    public static class ProcessResult {
        // 内联样式
        public final Map<String, String> inlineStyles = new LinkedHashMap<>();
        
        // 要添加的类名
        public final Set<String> classNames = new HashSet<>();
        
        // 要设置的ID
        public String id;
        
        // 全局样式规则
        public final List<GlobalRule> globalRules = new ArrayList<>();
        
        // 上下文相关规则（需要解析&）
        public final List<ContextRule> contextRules = new ArrayList<>();
        
        // 是否需要系统级处理（样式组等）
        public boolean needsSystemProcessing = false;
    }
    
    /**
     * 全局样式规则
     */
    public static class GlobalRule {
        public final String selector;
        public final StyleRuleNode rule;
        
        public GlobalRule(String selector, StyleRuleNode rule) {
            this.selector = selector;
            this.rule = rule;
        }
    }
    
    /**
     * 上下文规则
     */
    public static class ContextRule {
        public final String selectorPattern;
        public final StyleRuleNode rule;
        
        public ContextRule(String selectorPattern, StyleRuleNode rule) {
            this.selectorPattern = selectorPattern;
            this.rule = rule;
        }
    }
    
    /**
     * 从AST节点获取字符串值
     */
    private String getStringValue(CHTLASTNode node) {
        if (node == null) return "";
        
        if (node instanceof StringLiteralNode) {
            return ((StringLiteralNode) node).getValue();
        } else if (node instanceof UnquotedLiteralNode) {
            return ((UnquotedLiteralNode) node).getValue();
        } else if (node instanceof NumberLiteralNode) {
            return ((NumberLiteralNode) node).getValue();
        }
        
        return node.toString();
    }
}
